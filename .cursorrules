# PF2E Visioner – Copilot Instructions

Purpose: Give coding AIs crisp, actionable guardrails for this repo. Follow these rules unless a maintainer explicitly asks otherwise.

## Golden rules

- Never introduce time-based loops (no setInterval/setTimeout) for core flows. Use hooks, debounced events, or batch cycles.
- Persist state only via token/scene flags under `flags["pf2e-visioner"]`. Merge, don’t overwrite.
- Favor batch ops over per-document updates. Use Scene updates for many tokens.
- UI uses ApplicationV2; avoid legacy Application patterns.
- No hidden global side effects. Prefer services and stores with explicit wiring.
- Keep hot paths synchronous where feasible. Async only when necessary and outside render-critical loops.
- Check HANDOVER.md first.
- Always run tests in terminal rather than internal tool.
- Every bugfix requires a test if there isn't any.
- Dont write long functions, break to several functions to keep readable.
- Never mix test code and production code.
- Use i18n keys for all user-facing text. Update lang/\*.json as needed.

## Architecture you must respect

- Stores (single-responsibility): `scripts/stores/*` – visibility/cover maps, simple get/set.
- Services (cross-cutting): `scripts/services/*` – orchestration, perception refresh, visuals, sockets.
- UI controllers: `scripts/managers/*` – thin ApplicationV2 controllers.
- Hooks: `scripts/hooks/*` – registration split by concern; `hooks/registration.js` composes.
- Cover/Visibility engines: `scripts/cover/*`, `scripts/visibility/*` – effect aggregation, batch processing.
- Chat automation: `scripts/chat/*` – actions, dialogs, results.
- Public API: `scripts/api.js` – stable surface. Internal helpers in `services/api-internal.js`.

Contract for state

- Visibility states: observed | concealed | hidden | undetected.
- Cover states: none | lesser | standard | greater.
- Flags shape per token:
  - `flags["pf2e-visioner"].visibility[observerId] = state`
  - `flags["pf2e-visioner"].cover[attackerId] = state`
- Never wipe the object; deep-merge when writing.

## Performance patterns

- Batch writes and effect rebuilds; avoid per-target loops with immediate awaits.
- Defer heavy work to GM or token owners to avoid duplicate computation.
- Avoid triggering `refreshLighting`; refresh vision/occlusion only when needed.
- Debounce/react to Foundry hooks (move/animate/lighting) and avoid feedback loops.

## UI/UX conventions

- Color and styling come from CSS custom properties in `styles/*.css`; don’t hardcode hex values. Respect colorblind modes.
- Token Manager and dialogs are responsive; keep templates clean and class-driven (no inline styles).
- Bulk actions must support Apply/Revert per-row and bulk Apply All/Revert All.

## Testing + quality gates

- Jest test suite must pass. Use the provided npm scripts.
- Maintain coverage; add unit tests for helpers and integration tests for flows.
- Run linting and keep ESModule imports tidy.
- Prefer deterministic tests; use provided Foundry/PF2e mocks.
- Never change production code to accommodate tests. fix the test instead.
- Never run a test with debug logs, if debug is needed set debugger expressions and tell me to run in debug and ill tell you waht you need to know

## Do/Don’t examples

Do

- Add a service and register it via hooks/registration or API init.
- Read/merge token flags with defensive null checks.
- Batch update token flags and then trigger a single visuals refresh.
- Use i18n keys; update `lang/*.json` when introducing user-facing text.

Don’t

- Write directly to `token.document.flags.pf2e-visioner = {...}` (overwrites!).
- Call `canvas.perception.update({ refreshLighting: true })`.
- Add long-lived timers or polling for visibility/cover.
- Introduce UI inline styles or hardcoded colors.

## Common pitfalls (and the correct approach)

- Token vs TokenDocument: when in doubt, operate on TokenDocument for persistence; use `token.document`.
- Cross-client updates: prefer socket-based perception refresh via services; avoid duplicating work across clients.
- Effect lifecycle: aggregate effects are intentional; clean up after roll-time effects; don’t duplicate.
- Party tokens: respect preservation/restoration services and caches; avoid deleting/restoring flags manually.

## How to add a feature safely

1. Identify the layer(s): store vs service vs UI.
2. Add minimal store getters/setters (pure data), then a service for orchestration.
3. Wire hooks/UI to call the service. Keep UI thin.
4. Write unit tests (helpers/service) and an integration test if flow touches canvas/chat.
5. Update docs if you change behavior (README/DEVELOPMENT/ARCHITECTURE).

## Commands you can run

- Run unit tests: use the VS Code task “Run unit tests” (npm test).
- Re-run subset: use the "Re-run unit tests (subset)" task where provided.

## File map for common tasks

- Visibility map read/write: `scripts/stores/visibility-map.js`
- Cover map read/write: `scripts/stores/cover-map.js`
- Visual refresh: `scripts/services/visual-effects.js`
- Hook wiring: `scripts/hooks/registration.js`, `scripts/hooks/*.js`
- Chat automation: `scripts/chat/**` (dialogs, processors, services)
- Public API: `scripts/api.js`

## Localization and accessibility

- Add English strings to `lang/en.json` and mirror to other locales with TODO comments.
- Keep ARIA/tooltips consistent; reuse existing tooltip helpers where possible.

## Security/permissions

- Assume players have limited permissions. Guard actions by role; GM-first for destructive ops.

## When in doubt

- Check HANDOVER.md first. Align with patterns there.
- Prefer small, reversible changes. Add TODO comments with clear follow-ups.
- If performance is impacted, add a benchmark test or a quick micro-benchmark under tests.

## Auto‑Visibility System (AVS) structuring

- Core orchestration lives in services; keep hot-path math/data pure and synchronous where possible.
- Dependency Injection (DI): Register services once and pass them explicitly; don’t reach for globals in core logic.

Key components

- Event‑Driven Visibility System (EDS): reacts to hooks and delegates to services; avoid long async operations inside event handlers.
- BatchProcessor: entry to batch recompute; never mutate flags directly here—go through services.
- Spatial index & filters: use viewport/range filtering before heavy processing.

Caches (use, don’t reinvent)

- PositionBatchCache: snapshot token positions for the batch.
- VisibilityMapBatchCache: snapshot original per‑observer maps to compare/reconcile.
- OverrideBatchCache: memoize per‑pair manual overrides; read via OverrideService; fall back to target flags if needed.
- Global caches: GlobalLos/GlobalVisibility caches with TTL; prefer them for repeated queries within the same frame/tick.

Services contract

- VisibilityMapService: single source of truth for reading/writing visibility maps; deep‑merge writes only.
- OverrideService: best‑effort sync lookup `getActiveOverrideForTokens(observer, target)`; only read in hot paths.
- Visual effects service: trigger one consolidated refresh after batch writes; do not call `refreshLighting`.

Do

- Wire EDS → BatchProcessor with services injected via DI.
- Filter candidates by viewport and max range before per‑pair work.
- Batch flag updates and perform a single visuals/perception refresh via services.
- Keep batch steps side‑effect free until the final commit phase.

Don’t

- Don’t access `visibilityMapFunctions` or other legacy function deps—use services.
- Don’t await per‑target writes in a loop; collect and batch.
- Don’t compute the same pair twice—check caches first.
- Don’t introduce timers/polling to drive AVS; rely on hooks and debounced signals.
