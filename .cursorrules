# PF2E Visioner – Cursor Instructions

Purpose: Provide coding AIs with clear, actionable guidelines for this repository. These rules must be followed unless explicitly overridden by a maintainer.

## Prerequisites

- Read HANDOVER.md before making changes
- Consult API references:
  - FoundryVTT: https://foundryvtt.com/api/
  - PF2e System: https://github.com/foundryvtt/pf2e
  - PF2e Rules: https://2e.aonprd.com/

## Communication Standards

- Be concise; prioritize clarity and brevity over formality
- Use GitHub CLI for all GitHub interactions
- At the end of implementation plans, provide a concise list of unresolved questions

## Architecture Principles

### Module Structure

- **Stores** (`scripts/stores/*`): Single-responsibility data access; visibility/cover maps with simple get/set operations
- **Services** (`scripts/services/*`): Cross-cutting orchestration, perception refresh, visuals, sockets
- **UI Controllers** (`scripts/managers/*`): Thin ApplicationV2 controllers
- **Hooks** (`scripts/hooks/*`): Registration split by concern; `hooks/registration.js` provides central composition
- **Engines** (`scripts/cover/*`, `scripts/visibility/*`): Effect aggregation and batch processing
- **Chat Automation** (`scripts/chat/*`): Actions, dialogs, results
- **Public API** (`scripts/api.js`): Stable external interface; internal helpers in `services/api-internal.js`

### Architectural Constraints

- No hidden global side effects; prefer services and stores with explicit dependency injection
- All UI must use ApplicationV2; legacy Application patterns are prohibited
- Keep functions focused and concise; break complex functions into smaller, single-purpose functions
- Do not add code comments except for TODO comments with clear follow-up actions
- Do not modify, rename, or refactor code unless specifically instructed
- Never mix test code with production code

## State Management

### Persistence Contract

- All state must persist via token/scene flags under `flags["pf2e-visioner"]`
- Always deep-merge flags; never overwrite entire flag objects
- Use service methods for all flag mutations; never write directly to `token.document.flags.pf2e-visioner = {...}`

### State Definitions

**Visibility states** (PF2e compliance required):

- `observed`: Full visibility, no penalties
- `concealed`: DC 5 flat check required to target
- `hidden`: DC 11 flat check required to target
- `undetected`: Location unknown, cannot target

**Cover states** (PF2e compliance required):

- `none`: No AC bonus
- `lesser`: +1 AC
- `standard`: +2 AC
- `greater`: +4 AC

**Flag structure**:

```javascript
flags['pf2e-visioner'].visibility[observerId] = state;
flags['pf2e-visioner'].cover[attackerId] = state;
```

## Performance Requirements

- Favor batch operations over per-document updates; use `Scene.updateEmbeddedDocuments` for multiple tokens
- Batch all writes and effect rebuilds; avoid per-target loops with immediate awaits
- Defer heavy computation to GM or token owners to prevent duplicate work across clients
- Keep hot paths synchronous; reserve async operations for non-render-critical paths only
- Never introduce time-based loops (`setInterval`/`setTimeout`) for core flows; use hooks, debounced events, or batch cycles
- Never call `canvas.perception.update({ refreshLighting: true })`; refresh vision/occlusion only when needed
- Debounce reactions to Foundry hooks (move/animate/lighting) to prevent feedback loops

## Testing Standards

- Jest test suite must pass; use provided npm scripts (Jest, not Vitest)
- Maintain test coverage; add unit tests for helpers and integration tests for canvas/chat flows
- Use deterministic tests with provided Foundry/PF2e mocks
- Never modify production code to accommodate tests; fix the test implementation instead
- If existing unit tests fail, do not modify them; fix the underlying code
- Every bugfix requires a corresponding test if one does not exist
- Never run tests with debug logs; use debugger expressions when debugging is needed
- Run linting and maintain clean ESModule imports

## UI/UX Standards

- All user-facing text must use i18n keys; update `lang/*.json` files accordingly
- Colors and styling must use CSS custom properties from `styles/*.css`; hardcoded hex values are prohibited
- Support all colorblind modes: Protanopia, Deuteranopia, Tritanopia, Achromatopsia
- Token Manager and dialogs must be responsive
- Templates must be class-driven; inline styles are prohibited
- Bulk actions must support per-row Apply/Revert and bulk Apply All/Revert All operations
- Add English strings to `lang/en.json`; mirror to other locales with TODO comments
- Maintain consistent ARIA attributes and tooltips; reuse existing tooltip helpers

## Security & Permissions

- Assume players have limited permissions
- Guard all actions by user role; GM-only operations must be enforced
- Verify token ownership before allowing state changes

## Common Pitfalls & Solutions

| Pitfall                | Correct Approach                                                                                 |
| ---------------------- | ------------------------------------------------------------------------------------------------ |
| Token vs TokenDocument | Operate on `TokenDocument` for persistence; use `token.document`                                 |
| Cross-client updates   | Use socket-based perception refresh via services; avoid duplicate computation                    |
| Effect lifecycle       | Aggregate effects are intentional; clean up after roll-time effects; do not duplicate            |
| Party token flags      | Respect preservation/restoration services and caches; never manually delete/restore flags        |
| Flag overwrites        | Use service methods that deep-merge; never write `flags.pf2e-visioner = {...}` directly          |
| Refresh lighting       | Do not call `canvas.perception.update({ refreshLighting: true })`; refresh vision/occlusion only |

## Feature Development Process

1. **Identify layers**: Determine whether changes affect stores, services, or UI
2. **Implement data layer**: Add minimal store getters/setters (pure data operations)
3. **Implement orchestration**: Add service layer for business logic
4. **Wire interfaces**: Connect hooks/UI to services; keep UI controllers thin
5. **Add tests**: Write unit tests for helpers/services; add integration tests if flow touches canvas/chat
6. **Update documentation**: Modify README/DEVELOPMENT/ARCHITECTURE as needed

## Auto-Visibility System (AVS)

### Core Principles

- Core orchestration resides in services; keep hot-path calculations and data operations pure and synchronous
- Use dependency injection; register services once and pass them explicitly; avoid globals in core logic

### Implementation Requirements

**Required:**

- Filter candidates by viewport and max range before per-pair processing
- Batch all flag updates and perform a single visuals/perception refresh via services
- Keep batch processing steps side-effect-free until the final commit phase
- Use Event-Driven Visibility System (EDS) → BatchProcessor pipeline with DI-injected services

**Prohibited:**

- Accessing `visibilityMapFunctions` or other legacy function dependencies; use services instead
- Awaiting per-target writes in loops; collect and batch all updates
- Computing the same pair twice; always check caches first
- Introducing timers or polling to drive AVS; rely on hooks and debounced signals

For detailed AVS architecture, refer to HANDOVER.md.

## Development Guidelines

- Prefer small, reversible changes
- Break long functions to small ones
- If performance regression is suspected, add benchmark tests or micro-benchmarks under `tests/`
- Do not delete debug logs until the user confirms the associated bug is fixed
